use std::collections::VecDeque;
use std::path::Path;

use async_std::fs::read_dir;
use async_std::path::PathBuf;
use futures::executor::block_on;
use futures::future::{join, join_all};
use futures::StreamExt;

use crate::query::checker::{Checker, Outcome};
use crate::query::matcher;
use crate::query::response::Response;
use crate::query::service::Service;

pub struct QueryProcessor<'a> {
    checker: Checker<'a>,
}

impl<'a> QueryProcessor<'a> {
    /// New query processor
    pub fn new() -> Self {
        let ignored_paths = crate::CONFIG.get_ignore_paths();
        QueryProcessor {
            checker: Checker::new(ignored_paths),
        }
    }

    /// Query based on the request, and return serialized bytes of the services
    pub fn query(&self, req: &str) -> Vec<u8> {
        block_on(self.async_query(req))
    }

    /// Async query
    async fn async_query(&self, req: &str) -> Vec<u8> {
        let req = req.to_lowercase();
        let (cached_services, updated_services) = join(
            self.query_system_services(&req),
            self.query_updated_services(&req),
        )
        .await;
        cached_services
            .iter()
            .chain(updated_services.iter())
            .collect::<Response<_>>()
            .serialize_to_json()
    }

    /// Cached services are either loaded from cache or generated by walking through directories
    async fn query_system_services(&self, req: &str) -> Vec<Service> {
        join_all(
            crate::CONFIG
                .get_system_paths()
                .into_iter()
                .map(|path| self.walk_paths(path)),
        )
        .await
        .into_iter()
        .flatten()
        .map(Service::new)
        .filter(|service| matcher::match_query(&req, &service.title))
        .collect()
    }

    async fn query_updated_services(&self, req: &str) -> Vec<Service> {
        join_all(
            crate::CONFIG
                .get_users_paths()
                .into_iter()
                .map(|path| self.walk_paths(path)),
        )
        .await
        .into_iter()
        .flatten()
        .map(Service::new)
        .filter(|service| matcher::match_query(&req, &service.title))
        .collect()
    }

    /// Recursively iterate through files and folders, and return all legit file paths
    async fn walk_paths<P: AsRef<Path>>(&self, entry: P) -> Vec<PathBuf> {
        let entry = entry.as_ref();
        match self.checker.check(entry) {
            Outcome::UnwantedPath => vec![],
            Outcome::BundlePath => vec![entry.to_owned().into()],
            Outcome::NormalPath => {
                let (mut res, mut remaining) = self.separate_files_and_dirs(entry).await;
                while let Some(entry) = remaining.pop_front() {
                    let (processed, unprocessed) = self.separate_files_and_dirs(&entry).await;
                    res.extend(processed);
                    remaining.extend(unprocessed);
                }
                res
            }
        }
    }

    /// walk through all files in the given entry, and return paths for files and directories
    async fn separate_files_and_dirs<P: AsRef<Path>>(
        &self,
        entry: P,
    ) -> (Vec<PathBuf>, VecDeque<PathBuf>) {
        let entry = entry.as_ref();
        let mut processed = Vec::new();
        let mut folders = VecDeque::new();
        let mut read_folder = match read_dir(&entry).await {
            Ok(read_folder) => read_folder,
            Err(err) => {
                println!("Read folder error: {}", err);
                return (processed, folders);
            }
        };
        while let Some(Ok(path)) = read_folder.next().await {
            let path = path.path();
            match self.checker.check(&path) {
                Outcome::UnwantedPath => continue,
                Outcome::BundlePath => processed.push(path),
                Outcome::NormalPath => folders.push_back(path),
            }
        }
        (processed, folders)
    }
}

#[cfg(test)]
mod query_test {
    use async_std::path::PathBuf;
    use futures::executor::block_on;

    use crate::query::query::QueryProcessor;

    type QP<'a> = QueryProcessor<'a>;

    const APP_PATH: &str = "/System/Applications/Books.app";
    const APP_FOLDER_PATH: &str = "/System/Applications";

    #[test]
    fn test_walk_dir_single() {
        let settings = crate::configurator::get_content();
        std::env::set_var("SETTINGS", settings);
        let processor = QP::new();
        let single_file = PathBuf::from(APP_PATH);
        let expected = PathBuf::from(APP_PATH);
        let res = block_on(processor.walk_paths(&single_file));
        assert_eq!(&expected, &res[0]);
    }

    #[test]
    fn test_walk_dir_inside_book() {
        let settings = crate::configurator::get_content();
        std::env::set_var("SETTINGS", settings);
        let processor = QP::new();
        let content = PathBuf::from(APP_FOLDER_PATH);
        let res = block_on(processor.walk_paths(&content));
        assert_eq!(52, res.len());
    }
}
